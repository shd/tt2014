\documentclass[12pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
%\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{bnf}
%\usepackage[UglyObsolete,tight,heads=LaTeX] {diagrams}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{proof}
\begin{document}

\newcommand{\chr}[1]{\mbox{`\texttt{#1}'}}
\newcommand{\nt}[1]{\mbox{#1}}
\newcommand{\rep}[2]{\{#1\}^#2}

Домашние задания по курсу <<Теория типов>>

\begin{enumerate}
\item На вход вашей программе дается файл task1.in,
содержащий лямбда-выражение в следующей грамматике:
\begin{bnf}\begin{eqnarray*}
<\nt{Выражение}> & ::= & [<\nt{Применение}>] \chr{\textbackslash} <\nt{Переменная}> \chr{.} <\nt{Выражение}> \\
  & | & <\nt{Применение}> \\
<\nt{Применение}> & ::= & <\nt{Применение}> <\nt{Атом}> | <\nt{Атом}> \\                         
<\nt{Атом}> & ::= & \chr{(} <\nt{Выражение}> \chr{)} | <\nt{Переменная}> \\
<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
\end{eqnarray*}\end{bnf}%
Аргументы-переменные в применении должны разделяться пробелом. В остальных случаях пробелы могут
отсутствовать.
Любые пробелы между нетерминальными символами (кроме пробела, разделяющего аргументы в применении)
--- а также начальные и конечные пробелы в строке --- должны игнорироваться. Символы табуляции,
возврата каретки и перевода строки должны трактоваться как пробелы.

Требуется расставить все недостающие скобки вокруг всех абстракций и применений,
и напечатать получившийся результат в файле task1.out.

Например:\\\chr{\textbackslash{}a.\textbackslash{}b.a b c (\textbackslash{}d.e \textbackslash{}f.g) h}\\
должно превратиться в\\
\chr{(\textbackslash{}a.(\textbackslash{}b.((((a b) c) (\textbackslash{}d.(e (\textbackslash{}f.g)))) h))))}

\item В файле task2.in задано некоторое лямбда-выражение, требуется найти список свободных
переменных в нем и напечатать в алфавитном порядке, по идентификатору на строке.

\item В файле task3.in задана подстановка в некоторое лямбда-выражение в следующем синтаксисе 
(расширение определения из первой задачи):
\begin{bnf}\begin{eqnarray*}
<\nt{Условие}> & ::= & <\nt{Выражение}> \chr{[} <\nt{Переменная}> \chr {:=} <\nt{Выражение}> \chr{]}
\end{eqnarray*}\end{bnf}%

Требуется в выходном файле task3.out привести результат подстановки, либо указать фразу
\chr{Нет свободы для подстановки для переменной } <\nt{Переменная}>.

\item В файле task4.in дано лямбда-выражение, имеющее нормальную форму, требуется 
нормализовать его и результат записать в файл task4.out. 

\item Преобразовать лямбда-выражение в комбинаторное выражение в базисе $SKI$. 

На вход в файле task5.in задано лямбда-выражение, выведите в файл task5.out бета-эквивалентное 
ему выражение в базисе $SKI$. Результирующее выражение должно соответствовать грамматике для
лямбда-выражений, но не должно содержать лямбда-абстракций. В качестве значений можно использовать
только большие буквы \chr{S}, \chr{K} и \chr{I} и свободные переменные из исходного выражения.

\item Унификация термов. На вход в файле task6.in задан список уравнений в алгебраических термах, 
по уравнению на строке. Каждое уравнение соответствует следующей грамматике:

\begin{bnf}\begin{eqnarray*}
<\nt{Уравнение}> & ::= & <\nt{Терм}> \chr{=} <\nt{Терм}>\\
<\nt{Терм}> & ::= & <\nt{Функция}> \chr{(} <\nt{Терм}> \rep{\chr{,} \nt{Терм}}{*} \chr{)} | <\nt{Переменная}> \\
<\nt{Функция}> & ::= & (\chr{a}\dots\chr{h}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*} \\
<\nt{Переменная}> & ::= & (\chr{i}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
\end{eqnarray*}\end{bnf}%

Решите эту систему уравнений и выведите в файл task6.out наиболее общую подстановку, по строке
на каждую переменную, используя следующую грамматику:

\begin{bnf}\begin{eqnarray*}
<\nt{Строка подстановки}> & ::= & <\nt{Переменная}> \chr{=} <\nt{Терм}>\\
\end{eqnarray*}\end{bnf}%

\item Просто типизированное лямбда-исчисление. На вход в файле task7.in задано лямбда-выражение.
Выведите в файл task7.out какой-нибудь наиболее общий тип для этого выражения в просто типизированном 
лямбда-исчислении (если этот тип существует), или укажите, что выражение типа не имеет.

Результат должен соответствовать следующей грамматике:

\begin{bnf}\begin{eqnarray*}
<\nt{Ответ}> & ::= & <\nt{Тип}> \chr{\textbackslash{}n} <\nt{Контекст}> | \chr{Лямбда-выражение не имеет типа.} \\
<\nt{Контекст}> & ::= & \rep{<\nt{Переменная}> \chr{:} <\nt{Тип}> \chr{\textbackslash{}n}}{*} \\
<\nt{Тип}> & ::= & <\nt{Терм}> | <\nt{Терм}> \chr{->} <\nt{Тип}>\\
<\nt{Терм}> & ::= & <\nt{Перем}> | \chr{(} <\nt{Тип}> \chr{)}\\
<\nt{Перем}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
\end{eqnarray*}\end{bnf}%

%\item Лямбда-куб (для групп 2538-2539). Проверить доказательство типизации выражения, сформулированное
%в одной из типовых систем лямбда-куба. Входное доказательство будет приведено в следующем формате:
%\begin{bnf}\begin{eqnarray*}
%<\nt{Доказательство}> & ::= & <\nt{Формат}> \chr{\textbackslash{}n}> <\nt{Список-формул}>\\
%<\nt{Формат}> & ::= & <\nt{Пара-сортов}> \rep{\chr{,} <\nt{Пара-сортов}>}{*} | \chr{F}\\
%<\nt{Пара-сортов}> & ::= & \chr{(} (\chr{#}|\chr{*}) \chr{,} (\chr{#}|\chr{*}) \chr{)}\\
%<\nt{Список-формул}> & ::= & \rep{\rep{\chr{.}}* <\nt{Абстракция}> \chr{\textbackslash{}n}}{+}\\
%<\nt{Абстракция}> & ::= & [<\nt{Применение}>] (\chr{\textbackslash}|\chr{\%}) <\nt{Переменная}> \chr{:} <> \chr{.} <\nt{Абстракция}> \\
%  & | & [<\nt{Применение}>] \chr{^} <\nt{Переменная}> \chr{.} <\nt{Абстракция}> \\
%  & | & <\nt{Применение}> \\
%<\nt{Применение}> & ::= & <\nt{Применение}> <\nt{Атом}> | <\nt{Атом}> \\                         
%<\nt{Атом}> & ::= & \chr{(} <\nt{Абстракция}> \chr{)} | <\nt{Переменная}> \\
%<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
%\end{eqnarray*}\end{bnf}%
%
%В начале каждого файла в первой строке идет информация о типе используемого
%исчисления. Там указывается либо конкретный тип используемого исчисления
%(путем перечисления параметров для дополнительных аксиом лямбда-куба), либо

%\item Построение доказательства в системе F (для групп 2538-2539; задача на
%выбор может быть заменена на 10 или 11). В условиях задачи 13 (алгоритм W) 
%для типизируемого в HM лямбда-выражения нужно построить доказательство типизации 
%лямбда-выражения в системе F. На вход в файле task9.in подается формула
%(в соответствии с условием задачи 13), на выходе в файле task9.out должно быть
%приведено доказательство в формате задачи 8.
%
%\item 
%
%Доказательство представлено в виде дерева - перед каждой формулой присутствует
%некоторое количество точек, говорящих о вложенности утверждения.
%
\item[12.] Расширенное лямбда-исчисление. 
На вход программы в файле task12.in задается выражение в лямбда-исчислении
с конструкцией let. Выражение соответствует следующей грамматике:

\begin{bnf}\begin{eqnarray*}
<\nt{Выражение}> & ::= & \chr{let} <\nt{Переменная}> \chr{=} <\nt{Выражение}> \chr{in} <\nt{Выражение}>\\
                 & | & <\nt{Абстракция}>\\
<\nt{Абстракция}> & ::= & [<\nt{Применение}>] \chr{\textbackslash{}} <\nt{Переменная}> \chr{.} <\nt{Абстракция}> \\
                & | & <\nt{Применение}> \\
<\nt{Применение}> & ::= & <\nt{Применение}> <\nt{Терм}> | <\nt{Терм}> \\                         
<\nt{Терм}> & ::= & \chr{(} <\nt{Выражение}> \chr{)} \\
		& | & <\nt{Переменная}>\\
                & | & \chr{F}|\chr{T}|\chr{If}|\chr{Y}|\chr{Plus}|\chr{Minus}|\chr{Eq}|\rep{\chr{0}\dots\chr{9}}{+}\\
                & | & \chr{<}<\nt{Выражение}>\chr{,}<\nt{Выражение}>\chr{>} | \chr{PrL} | \chr{PrR}\\
                & | & \chr{InL} | \chr{InR} | \chr{Case}\\
<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
\end{eqnarray*}\end{bnf}%
Аналогично простым лямбда-выражениям, 
если подряд указаны какие-либо идентификаторы или ключевые слова \chr{let} и \chr{in}, 
то они будут разделяться пробелом.
Любые другие пробелы --- а также начальные и конечные пробелы в строке --- должны игнорироваться. Символы табуляции,
возврата каретки и перевода строки должны трактоваться как пробелы.

Требуется нормализовать выражение. Для переменных особого вида следует применять следующие
правила редукции:

\begin{tabular}{ll}
Исходное выражение & Бета-редукция выражения\\
\hline
\chr{If T t e} & \chr{t}\\
\chr{If F t e} & \chr{e}\\
\chr{Plus x y} & $(x+y)\%2^{63}$, если x, y --- числа, иначе --- ошибка\\
\chr{Minus x y} & $(x-y)\%2^{63}$, если x, y --- числа, иначе --- ошибка\\
\chr{Eq x y} & если $x$, $y$ --- не числа, то ошибка; если $x=y$, то \chr{T}, иначе \chr{F}\\
\chr{Y f} & \chr{f (Y f)}\\
\chr{PrL <a,b>} & \chr{a}\\
\chr{PrR <a,b>} & \chr{b}\\
\chr{Case (InL x) l r} & \chr{l x}\\
\chr{Case (InR y) l r} & \chr{r y}
\end{tabular}%

Частичное применение переменных особого вида допускается (в этом случае имеет
место классический карринг). 
Если какое-то применение переменной особого вида отсутствует в списке 
(например, \chr{If 0 1 2}) --- то его редукция должна приводить к ошибке.

В качестве примеров к программе должны быть приложены выражения для вычисления:
\begin{itemize}
\item по числу $n$ ($0 \le n \le 91$) вычислить $n$-е число Фибоначчи $F_n$ 
(подсказка: $F_{91} = 7540113804746346429$)
\item по числу $n$ вернуть упорядоченную пару $<a,b>$, где $a$ --- число цифр
в двоичном разложении $n$ (без ведущих нулей), а $b$ --- сумма цифр в двоичном
разложении.
\end{itemize}

\item[13.] Алгоритм $W$.

На вход программе передается файл task13.in, содержащий расширенное лямбда-выражение.
Требуется применить алгоритм $W$ и выдать в выходной файл результирующий тип и контекст
в следующей грамматике:

\begin{bnf}\begin{eqnarray*}
<\nt{Ответ}> & ::= & <\nt{Тип}> \chr{\textbackslash{}n} <\nt{Контекст}> | \chr{Лямбда-выражение не имеет типа.} \\
<\nt{Контекст}> & ::= & \rep{<\nt{Переменная}> \chr{:} <\nt{Тип}> \chr{\textbackslash{}n}}{*} \\
<\nt{Тип}> & ::= & <\nt{Дизъюнкция}> | <\nt{Дизъюнкция}> \chr{->} <\nt{Тип}>\\
<\nt{Дизъюнкция}> & ::= & <\nt{Дизъюнкция}> \chr{|} <\nt{Конъюнкция}>\\
                  & | & <\nt{Конъюнкция}>\\
<\nt{Конъюнкция}> & ::= & <\nt{Конъюнкция}> \chr{\&} <\nt{Атом}> | <\nt{Атом}>\\
<\nt{Атом}> & ::= & <\nt{Переменная}> | \chr{Bool} | \chr{Int} | \chr{(} <\nt{Тип}> \chr{)}\\
<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
\end{eqnarray*}\end{bnf}%

У выражений особого вида должны быть следующие особые типы:

\begin{tabular}{ll}
Имя & Тип\\
\hline
T,F & $Bool$\\
If & $\forall a (Bool \rightarrow a \rightarrow a \rightarrow a) $\\
$0,1,\dots,2^{63}-1$ & $Int$\\
Plus & $Int \rightarrow Int \rightarrow Int$\\
Minus & $Int \rightarrow Int \rightarrow Int$\\
Eq & $Int \rightarrow Int \rightarrow Bool$\\
$< x^a, y^b >$ & $a \& b$\\
PrL & $\forall a \forall b (a\&b \rightarrow a)$\\
PrR & $\forall a \forall b (a\&b \rightarrow b)$\\
InL & $\forall a \forall b (a \rightarrow a | b)$\\
InR & $\forall b \forall b (b \rightarrow a | b)$\\
Case & $\forall a \forall b \forall c (a | b \rightarrow (a\rightarrow c) \rightarrow (b\rightarrow c) \rightarrow c)$\\
Y & $\forall a ((a \rightarrow a) \rightarrow a)$
\end{tabular}%

Убедитесь, что решения для примеров из предыдущей задачи правильно типизируются.

\end{enumerate}

\end{document}
