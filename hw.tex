\documentclass[12pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
%\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{bnf}
%\usepackage[UglyObsolete,tight,heads=LaTeX] {diagrams}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{proof}
\begin{document}

\newcommand{\chr}[1]{\mbox{`\texttt{#1}'}}
\newcommand{\nt}[1]{\mbox{#1}}
\newcommand{\rep}[2]{\{#1\}^#2}

\begin{center}{\Large Домашние задания по курсу <<Теория типов>>}\\весна 2015 г.\end{center}

\begin{enumerate}
\item На вход вашей программе дается файл task1.in,
содержащий лямбда-выражение в следующей грамматике:
\begin{bnf}\begin{eqnarray*}
<\nt{Выражение}> & ::= & [<\nt{Применение}>] \chr{\textbackslash} <\nt{Переменная}> \chr{.} <\nt{Выражение}> \\
  & | & <\nt{Применение}> \\
<\nt{Применение}> & ::= & <\nt{Применение}> <\nt{Атом}> | <\nt{Атом}> \\                         
<\nt{Атом}> & ::= & \chr{(} <\nt{Выражение}> \chr{)} | <\nt{Переменная}> \\
<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{a}\dots\chr{z}|\chr{0}\dots\chr{9}|\chr{'}}{*} 
\end{eqnarray*}\end{bnf}%
Аргументы-переменные в применении должны разделяться пробелом. В остальных случаях пробелы могут
отсутствовать.
Любые пробелы между нетерминальными символами (кроме пробела, разделяющего аргументы в применении)
--- а также начальные и конечные пробелы в строке --- должны игнорироваться. Символы табуляции,
возврата каретки и перевода строки должны трактоваться как пробелы.

Требуется расставить все недостающие скобки вокруг всех абстракций и применений,
и напечатать получившийся результат в файле task1.out.

Например:\\\chr{\textbackslash{}a.\textbackslash{}b.a b c (\textbackslash{}d.e \textbackslash{}f.g) h}\\
должно превратиться в\\
\chr{(\textbackslash{}a.(\textbackslash{}b.((((a b) c) (\textbackslash{}d.(e (\textbackslash{}f.g)))) h)))}

\item В файле task2.in задано некоторое лямбда-выражение, требуется найти список свободных
переменных в нем и напечатать в алфавитном порядке, по идентификатору на строке.

\item В файле task3.in задана подстановка в некоторое лямбда-выражение в следующем синтаксисе 
(расширение определения из первой задачи):
\begin{bnf}\begin{eqnarray*}
<\nt{Условие}> & ::= & <\nt{Выражение}> \chr{[} <\nt{Переменная}> \chr {:=} <\nt{Выражение}> \chr{]}
\end{eqnarray*}\end{bnf}%

Требуется в выходном файле task3.out привести результат подстановки, либо указать фразу
\chr{Нет свободы для подстановки для переменной } <\nt{Переменная}>.

\item В файле task4.in дано лямбда-выражение, имеющее нормальную форму, требуется 
нормализовать его и результат записать в файл task4.out. 

%\item Преобразовать лямбда-выражение в комбинаторное выражение в базисе $SKI$. 
%
%На вход в файле task5.in задано лямбда-выражение, выведите в файл task5.out бета-эквивалентное 
%ему выражение в базисе $SKI$. Результирующее выражение должно соответствовать грамматике для
%лямбда-выражений, но не должно содержать лямбда-абстракций. В качестве значений можно использовать
%только большие буквы \chr{S}, \chr{K} и \chr{I} и свободные переменные из исходного выражения.

\item Унификация термов. На вход в файле task5.in задан список уравнений в алгебраических термах, 
по уравнению на строке. Каждое уравнение соответствует следующей грамматике:
\begin{bnf}\begin{eqnarray*}
<\nt{Уравнение}> & ::= & <\nt{Терм}> \chr{=} <\nt{Терм}>\\
<\nt{Терм}> & ::= & <\nt{Функция}> \chr{(} <\nt{Терм}> \rep{\chr{,} \nt{Терм}}{*} \chr{)} | <\nt{Переменная}> \\
<\nt{Функция}> & ::= & (\chr{a}\dots\chr{h}) \rep{\chr{a}\dots\chr{z}|\chr{0}\dots\chr{9}|\chr{'}}{*} \\
<\nt{Переменная}> & ::= & (\chr{i}\dots\chr{z}) \rep{\chr{a}\dots\chr{z}|\chr{0}\dots\chr{9}|\chr{'}}{*} 
\end{eqnarray*}\end{bnf}%

Решите эту систему уравнений и выведите в файл task5.out наиболее общую подстановку, по строке
на каждую переменную, используя следующую грамматику:
\begin{bnf}\begin{eqnarray*}
<\nt{Строка подстановки}> & ::= & <\nt{Переменная}> \chr{=} <\nt{Терм}>\\
\end{eqnarray*}\end{bnf}%

\item Просто типизированное лямбда-исчисление. На вход в файле task6.in задано лямбда-выражение.
Выведите в файл task6.out какой-нибудь наиболее общий тип для этого выражения в просто типизированном 
лямбда-исчислении (если этот тип существует), или укажите, что выражение типа не имеет.

Результат должен соответствовать следующей грамматике:
\begin{bnf}\begin{eqnarray*}
<\nt{Ответ}> & ::= & <\nt{Тип}> \chr{\textbackslash{}n} <\nt{Контекст}> | \chr{Лямбда-выражение не имеет типа.} \\
<\nt{Контекст}> & ::= & \rep{<\nt{Переменная}> \chr{:} <\nt{Тип}> \chr{\textbackslash{}n}}{*} \\
<\nt{Тип}> & ::= & <\nt{Типовый-терм}> | <\nt{Типовый-терм}> \chr{->} <\nt{Тип}>\\
<\nt{Типовый-терм}> & ::= & <\nt{Имя-типа}> | \chr{(} <\nt{Тип}> \chr{)}\\
<\nt{Имя-типа}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{a}\dots\chr{z}|\chr{0}\dots\chr{9}|\chr{'}}{*}
\end{eqnarray*}\end{bnf}%

%\item Лямбда-куб (для групп 2538-2539). Проверить доказательство типизации выражения, сформулированное
%в одной из типовых систем лямбда-куба. Входное доказательство будет приведено в следующем формате:
%\begin{bnf}\begin{eqnarray*}
%<\nt{Доказательство}> & ::= & <\nt{Формат}> \chr{\textbackslash{}n}> <\nt{Список-формул}>\\
%<\nt{Формат}> & ::= & <\nt{Пара-сортов}> \rep{\chr{,} <\nt{Пара-сортов}>}{*} | \chr{F}\\
%<\nt{Пара-сортов}> & ::= & \chr{(} (\chr{#}|\chr{*}) \chr{,} (\chr{#}|\chr{*}) \chr{)}\\
%<\nt{Список-формул}> & ::= & \rep{\rep{\chr{.}}* <\nt{Абстракция}> \chr{\textbackslash{}n}}{+}\\
%<\nt{Абстракция}> & ::= & [<\nt{Применение}>] (\chr{\textbackslash}|\chr{\%}) <\nt{Переменная}> \chr{:} <> \chr{.} <\nt{Абстракция}> \\
%  & | & [<\nt{Применение}>] \chr{^} <\nt{Переменная}> \chr{.} <\nt{Абстракция}> \\
%  & | & <\nt{Применение}> \\
%<\nt{Применение}> & ::= & <\nt{Применение}> <\nt{Атом}> | <\nt{Атом}> \\                         
%<\nt{Атом}> & ::= & \chr{(} <\nt{Абстракция}> \chr{)} | <\nt{Переменная}> \\
%<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
%\end{eqnarray*}\end{bnf}%
%
%В начале каждого файла в первой строке идет информация о типе используемого
%исчисления. Там указывается либо конкретный тип используемого исчисления
%(путем перечисления параметров для дополнительных аксиом лямбда-куба), либо

%\item Построение доказательства в системе F (для групп 2538-2539; задача на
%выбор может быть заменена на 10 или 11). В условиях задачи 13 (алгоритм W) 
%для типизируемого в HM лямбда-выражения нужно построить доказательство типизации 
%лямбда-выражения в системе F. На вход в файле task9.in подается формула
%(в соответствии с условием задачи 13), на выходе в файле task9.out должно быть
%приведено доказательство в формате задачи 8.
%
%\item 
%
%Доказательство представлено в виде дерева - перед каждой формулой присутствует
%некоторое количество точек, говорящих о вложенности утверждения.
%
%\item[12.] Расширенное лямбда-исчисление. 
%На вход программы в файле task12.in задается выражение в лямбда-исчислении
%с конструкцией let. Выражение соответствует следующей грамматике:
%
%\begin{bnf}\begin{eqnarray*}
%<\nt{Выражение}> & ::= & \chr{let} <\nt{Переменная}> \chr{=} <\nt{Выражение}> \chr{in} <\nt{Выражение}>\\
%                 & | & <\nt{Абстракция}>\\
%<\nt{Абстракция}> & ::= & [<\nt{Применение}>] \chr{\textbackslash{}} <\nt{Переменная}> \chr{.} <\nt{Абстракция}> \\
%                & | & <\nt{Применение}> \\
%<\nt{Применение}> & ::= & <\nt{Применение}> <\nt{Терм}> | <\nt{Терм}> \\                         
%<\nt{Терм}> & ::= & \chr{(} <\nt{Выражение}> \chr{)} \\
%		& | & <\nt{Переменная}>\\
%                & | & \chr{F}|\chr{T}|\chr{If}|\chr{Y}|\chr{Plus}|\chr{Minus}|\chr{Eq}|\rep{\chr{0}\dots\chr{9}}{+}\\
%                & | & \chr{<}<\nt{Выражение}>\chr{,}<\nt{Выражение}>\chr{>} | \chr{PrL} | \chr{PrR}\\
%                & | & \chr{InL} | \chr{InR} | \chr{Case}\\
%<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
%\end{eqnarray*}\end{bnf}%
%Аналогично простым лямбда-выражениям, 
%если подряд указаны какие-либо идентификаторы или ключевые слова \chr{let} и \chr{in}, 
%то они будут разделяться пробелом.
%Любые другие пробелы --- а также начальные и конечные пробелы в строке --- должны игнорироваться. Символы табуляции,
%возврата каретки и перевода строки должны трактоваться как пробелы.
%
%Требуется нормализовать выражение. Для переменных особого вида следует применять следующие
%правила редукции:
%
%\begin{tabular}{ll}
%Исходное выражение & Бета-редукция выражения\\
%\hline
%\chr{If T t e} & \chr{t}\\
%\chr{If F t e} & \chr{e}\\
%\chr{Plus x y} & $(x+y)\%2^{63}$, если x, y --- числа, иначе --- ошибка\\
%\chr{Minus x y} & $(x-y)\%2^{63}$, если x, y --- числа, иначе --- ошибка\\
%\chr{Eq x y} & если $x$, $y$ --- не числа, то ошибка; если $x=y$, то \chr{T}, иначе \chr{F}\\
%\chr{Y f} & \chr{f (Y f)}\\
%\chr{PrL <a,b>} & \chr{a}\\
%\chr{PrR <a,b>} & \chr{b}\\
%\chr{Case (InL x) l r} & \chr{l x}\\
%\chr{Case (InR y) l r} & \chr{r y}
%\end{tabular}%
%
%Частичное применение переменных особого вида допускается (в этом случае имеет
%место классический карринг). 
%Если какое-то применение переменной особого вида отсутствует в списке 
%(например, \chr{If 0 1 2}) --- то его редукция должна приводить к ошибке.
%
%В качестве примеров к программе должны быть приложены выражения для вычисления:
%\begin{itemize}
%\item по числу $n$ ($0 \le n \le 91$) вычислить $n$-е число Фибоначчи $F_n$ 
%(подсказка: $F_{91} = 7540113804746346429$)
%\item по числу $n$ вернуть упорядоченную пару $<a,b>$, где $a$ --- число цифр
%в двоичном разложении $n$ (без ведущих нулей), а $b$ --- сумма цифр в двоичном
%разложении.
%\end{itemize}
%
%\item[13.] Алгоритм $W$.
%
%На вход программе передается файл task13.in, содержащий расширенное лямбда-выражение.
%Требуется применить алгоритм $W$ и выдать в выходной файл результирующий тип и контекст
%в следующей грамматике:
%
%\begin{bnf}\begin{eqnarray*}
%<\nt{Ответ}> & ::= & <\nt{Тип}> \chr{\textbackslash{}n} <\nt{Контекст}> | \chr{Лямбда-выражение не имеет типа.} \\
%<\nt{Контекст}> & ::= & \rep{<\nt{Переменная}> \chr{:} <\nt{Тип}> \chr{\textbackslash{}n}}{*} \\
%<\nt{Тип}> & ::= & <\nt{Дизъюнкция}> | <\nt{Дизъюнкция}> \chr{->} <\nt{Тип}>\\
%<\nt{Дизъюнкция}> & ::= & <\nt{Дизъюнкция}> \chr{|} <\nt{Конъюнкция}>\\
%                  & | & <\nt{Конъюнкция}>\\
%<\nt{Конъюнкция}> & ::= & <\nt{Конъюнкция}> \chr{\&} <\nt{Атом}> | <\nt{Атом}>\\
%<\nt{Атом}> & ::= & <\nt{Переменная}> | \chr{Bool} | \chr{Int} | \chr{(} <\nt{Тип}> \chr{)}\\
%<\nt{Переменная}> & ::= & (\chr{a}\dots\chr{z}) \rep{\chr{0}\dots\chr{9}}{*} \rep{\chr{\'}}{*}
%\end{eqnarray*}\end{bnf}%
%
%У выражений особого вида должны быть следующие особые типы:
%
%\begin{tabular}{ll}
%Имя & Тип\\
%\hline
%T,F & $Bool$\\
%If & $\forall a (Bool \rightarrow a \rightarrow a \rightarrow a) $\\
%$0,1,\dots,2^{63}-1$ & $Int$\\
%Plus & $Int \rightarrow Int \rightarrow Int$\\
%Minus & $Int \rightarrow Int \rightarrow Int$\\
%Eq & $Int \rightarrow Int \rightarrow Bool$\\
%$< x^a, y^b >$ & $a \& b$\\
%PrL & $\forall a \forall b (a\&b \rightarrow a)$\\
%PrR & $\forall a \forall b (a\&b \rightarrow b)$\\
%InL & $\forall a \forall b (a \rightarrow a | b)$\\
%InR & $\forall b \forall b (b \rightarrow a | b)$\\
%Case & $\forall a \forall b \forall c (a | b \rightarrow (a\rightarrow c) \rightarrow (b\rightarrow c) \rightarrow c)$\\
%Y & $\forall a ((a \rightarrow a) \rightarrow a)$
%\end{tabular}%
%
%Убедитесь, что решения для примеров из предыдущей задачи правильно типизируются.
%
\end{enumerate}

\end{document}
